import jsPDF from 'jspdf';
import 'jspdf-autotable';
import pptxgen from 'pptxgenjs';
import * as XLSX from 'xlsx';

// --- PDF Generation from Simplified Markdown ---
const addWrappedText = (doc: jsPDF, text: string, x: number, y: number, maxWidth: number, options: any = {}) => {
  const lines = doc.splitTextToSize(text, maxWidth);
  doc.text(lines, x, y, options);
  return doc.getTextDimensions(lines).h;
};

export const createPdfFromMarkdown = (markdown: string, filename: string) => {
  const doc = new jsPDF();
  const pageHeight = doc.internal.pageSize.height;
  const pageWidth = doc.internal.pageSize.width;
  const margin = 15;
  let cursorY = margin;

  const lines = markdown.split('\n');
  let paragraph = '';

  const renderParagraph = () => {
    if (paragraph.trim()) {
        if (cursorY + 10 > pageHeight - margin - 20) { // Check before rendering
            doc.addPage();
            cursorY = margin;
        }
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(12);
        const textHeight = addWrappedText(doc, paragraph.trim(), margin, cursorY, 180);
        cursorY += textHeight + 4;
        paragraph = '';
    }
  };

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (cursorY > pageHeight - margin - 20) { // Add buffer for footer
      doc.addPage();
      cursorY = margin;
    }

    if (trimmedLine.startsWith('## ')) {
      renderParagraph();
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      const textHeight = addWrappedText(doc, trimmedLine.substring(3), margin, cursorY, 180);
      cursorY += textHeight + 4;
    } else if (trimmedLine.startsWith('# ')) {
      renderParagraph();
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(22);
      const textHeight = addWrappedText(doc, trimmedLine.substring(2), margin, cursorY, 180);
      cursorY += textHeight + 6;
    } else if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ')) {
      renderParagraph();
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(12);
      const bulletText = `â€¢ ${trimmedLine.substring(2)}`;
      const textHeight = addWrappedText(doc, bulletText, margin + 5, cursorY, 175);
      cursorY += textHeight + 2;
    } else if (trimmedLine) {
        paragraph += ' ' + trimmedLine;
    } else {
      renderParagraph();
      cursorY += 6; // Space for empty lines
    }
  }
  renderParagraph(); // Render any remaining paragraph


  // Add footer with page number and date to all pages
  const pageCount = doc.internal.getNumberOfPages();
  const now = new Date();
  const dateString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'italic');
    doc.setTextColor(128); // Gray color
    doc.text(`Generated by AKBAR AI on ${dateString}`, margin, pageHeight - 10);
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
  }

  doc.save(filename);
};

// --- Slides (PPTX) Generation ---
interface SlideData {
  title: string;
  content: string[] | string; // Can be a single string or an array
  layout?: string;
  imageBase64?: string;
  video_suggestion?: string;
}

export const createPptxFromSlidesData = (data: { slides: SlideData[] }, filename: string) => {
  const pptx = new pptxgen();
  pptx.layout = 'LAYOUT_16x9';
  const SLIDE_WIDTH = 10;
  const SLIDE_HEIGHT = 5.625;
  const MARGIN = 0.5;

  // --- Define Master Slides ---
  pptx.defineSlideMaster({
    title: 'AKBAR_TITLE',
    background: { color: '1F2937' },
  });

  pptx.defineSlideMaster({
    title: 'AKBAR_TITLE_IMAGE',
    background: { color: '1F2937' },
    objects: [{ 'image': { x: 0, y: 0, w: '100%', h: '100%' } }]
  });

  pptx.defineSlideMaster({
    title: 'AKBAR_CONTENT_MASTER',
    background: { color: '1F2937' },
    objects: [
      { 'placeholder': { options: { name: 'title', type: 'title', x: MARGIN, y: 0.25, w: SLIDE_WIDTH - (MARGIN*2), h: 0.75, fontSize: 32, bold: true, color: '818CF8' } } },
      { 'placeholder': { options: { name: 'body', type: 'body', x: MARGIN, y: 1.2, w: SLIDE_WIDTH - (MARGIN*2), h: 3.75, fontSize: 18, color: 'E5E7EB', bullet: true } } },
      { 'text': { text: 'AKBAR AI', options: { x: MARGIN, y: SLIDE_HEIGHT - 0.5, w: '45%', h: 0.25, fontSize: 10, color: 'A1A1AA' } } },
      { 'placeholder': { options: { name: 'slideNumber', type: 'slideNumber', x: SLIDE_WIDTH/2, y: SLIDE_HEIGHT - 0.5, w: '45%', h: 0.25, align: 'right', fontSize: 10, color: 'A1A1AA' } } }
    ]
  });

  pptx.defineSlideMaster({
      title: 'AKBAR_CONTENT_RIGHT_IMAGE',
      background: { color: '1F2937' },
      objects: [
          { 'placeholder': { options: { name: 'title', type: 'title', x: MARGIN, y: 0.25, w: (SLIDE_WIDTH / 2) - MARGIN, h: 0.75, fontSize: 28, bold: true, color: '818CF8' } } },
          { 'placeholder': { options: { name: 'body', type: 'body', x: MARGIN, y: 1.2, w: (SLIDE_WIDTH / 2) - MARGIN, h: 3.75, fontSize: 16, color: 'E5E7EB', bullet: true } } },
          { 'image': { x: SLIDE_WIDTH / 2 + MARGIN / 2, y: 0.5, w: (SLIDE_WIDTH / 2) - (MARGIN*1.5), h: SLIDE_HEIGHT - 1 } },
          { 'text': { text: 'AKBAR AI', options: { x: MARGIN, y: SLIDE_HEIGHT - 0.5, w: '45%', h: 0.25, fontSize: 10, color: 'A1A1AA' } } },
          { 'placeholder': { options: { name: 'slideNumber', type: 'slideNumber', x: SLIDE_WIDTH / 2, y: SLIDE_HEIGHT - 0.5, w: '45%', h: 0.25, align: 'right', fontSize: 10, color: 'A1A1AA' } } }
      ]
  });

  // --- Create Slides ---
  data.slides.forEach((slideData, index) => {
    let masterName = 'AKBAR_CONTENT_MASTER';
    if (index === 0) {
        masterName = slideData.layout === 'title_image' && slideData.imageBase64 ? 'AKBAR_TITLE_IMAGE' : 'AKBAR_TITLE';
    } else {
        masterName = slideData.layout === 'image_right' && slideData.imageBase64 ? 'AKBAR_CONTENT_RIGHT_IMAGE' : 'AKBAR_CONTENT_MASTER';
    }

    const slide = pptx.addSlide({ masterName });

    if (slideData.imageBase64) {
        slide.addImage({ data: slideData.imageBase64, placeholder: 'image' });
    }

    if (masterName === 'AKBAR_TITLE') {
      slide.addText(slideData.title || 'Presentasi', {
          x: MARGIN, y: 1.5, w: SLIDE_WIDTH - (MARGIN * 2), h: 1.5,
          align: 'center', fontSize: 48, bold: true, color: 'A78BFA'
      });
    } else if (masterName === 'AKBAR_TITLE_IMAGE') {
       slide.addText(slideData.title || 'Presentasi', {
            x: MARGIN, y: SLIDE_HEIGHT / 2 - 0.75, w: SLIDE_WIDTH - (MARGIN*2), h: 1.5,
            align: 'center', fontSize: 54, bold: true, color: 'FFFFFF',
            outline: { size: 2, color: '000000' },
            shadow: { type: 'outer', color: '000000', blur: 5, offset: 3, angle: 45, opacity: 0.8 }
        });
    } else {
      slide.addText(slideData.title || 'Tanpa Judul', { placeholder: 'title' });
    }

    if (slideData.content) {
      // Robustly handle content: ensure it's an array, filter out non-strings, then map to pptxgenjs format.
      const contentArray = [].concat(slideData.content); // Ensures it's always an array
      const validContent = contentArray.filter(item => typeof item === 'string' && item.trim() !== '');
      if (validContent.length > 0) {
        const contentAsObjects = validContent.map(text => ({ text }));
        slide.addText(contentAsObjects, { placeholder: 'body' });
      }
    }
    
    if (slideData.video_suggestion) {
        slide.addNotes(`Saran Video:\n${slideData.video_suggestion}`);
    }
  });

  pptx.writeFile({ fileName: filename });
};


// --- Sheets (XLSX) Generation ---
interface SheetData {
  headers: string[];
  rows: (string | number)[][];
}

export const createXlsxFromSheetData = (data: SheetData, filename: string) => {
  const ws = XLSX.utils.aoa_to_sheet([data.headers, ...data.rows]);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Data');
  XLSX.writeFile(wb, filename);
};